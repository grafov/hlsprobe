#!/usr/bin/env python2
# -*- coding:utf-8; mode:python -*-
# ॐ तारे तुत्तारे तुरे स्व
#
"""
HLS Prober for 451 Fahrenheit mediaserver.
Author: Alexander I.Grafov (Axel) <grafov@gmail.com>
This utility licensed under GPL v3.

Uses https://pypi.python.org/pypi/m3u8 for M3U8 playlists parsing.
Scripted in Python2 because m3u8 lib still don't work under Python3.
"""
__version__ = "0.2"

import sys
import os
import random
import time
import signal
import logging
import urllib2
import smtplib
import m3u8
import yaml
import optparse
from email.mime.text import MIMEText
from multiprocessing import Process, Queue
from subprocess import check_output, call, Popen, PIPE
from pprint import pprint

CONFIG = "~/.hlsproberc"


class CupertinoProbe:
    """ Parse variant and stream M3U8-playlists. Parser uses python `m3u8` library.
    Get playlist URLs from the task queue.
    """
    def __init__(self, cf, playlistq, chunkq, bugq, pno, log):
        """ Initialized with `cf` config, `playlistq` playlist queue, 
        `chunkq` chunk queje, `bugq` bug queue, `pno` prober instance number 
        and `log` logger object.
        """
        self.cf = cf
        self.playlistq = playlistq
        self.chunkq = chunkq
        self.bugq = bugq
        self.err = ErrContainer(bugq)
        self.pno = pno
        self.log = log

    def __call__(self):
        """ Read and parse a playlist."""
        while True:
            try:
                group, uri = self.playlistq.get(True)
                try:
                    playlist = m3u8.load(uri)
                except URLError:
                   self.log.warn("Failed to open %s %s stream " % (group, uri))
                   self.err("status", "stream", group, uri)
                   continue
                self.log.debug("Load playlist from %s %s" % (group, uri))
                time.sleep(self.cf["sleep"]["playlist-open"])
                if playlist.is_variant:
                    if not playlist.playlists:
                        self.bugq.put(("empty", "variant", group, uri))
                    # Load stream playlists and put them back to playlist queue
                    for stream in playlist.playlists:
                        while self.playlistq.full():
                            self.log.debug("Playlist queue is full. Probably you need to increase number of stream probers. Check `workers/stream-probers` value.")
                            time.sleep(3)
                        self.playlistq.put((group, "%s/%s" % (stream.baseuri, stream.uri)))
                else:
                    if not playlist.segments:
                        self.bugq.put(("empty", "chunklist", group, uri))
                    # Load URLs to media chunks and put them to chunk queue
                    for seg in playlist.segments:
                        while self.chunkq.full():
                            self.log.debug("Chunk queue is full. Probably you need to increase number of media probers. Check `workers/media-probers` value.")
                            time.sleep(3)
                        self.chunkq.put((group, uri, "%s/%s" % (playlist.baseuri, seg.uri)))
            except KeyboardInterrupt:
                self.log.info("Finalize cupertino prober %s." % self.pno)
            #except:
            #    self.bugq.put(["other", "stream"])
            #    continue


class MediaProbe:
    """ Get and analyze media chunks.
    """
    def __init__(self, cf, chunkq, bugq, pno, log):
        """ Initialized with `cf` configuration object, 
        `chunkq` chunk queue, `bugq` bug queue, 
        `pno` prober instance number and `log` logger object.
        """
        self.cf = cf
        self.chunkq = chunkq
        self.pno = pno
        self.log = log
        self.loaded = [] # cache list of already loaded chunks
        self.err = ErrContainer(bugq)

    def __call__(self):
        while True:
            try:
                group, stream, uri = self.chunkq.get(True)
                if uri in self.loaded:
                    self.log.debug("Chunk %s for %s %s already loaded." % (uri, group, stream))
                    continue
                resp = urllib2.urlopen(uri, timeout=self.cf["timeout"]["chunk-read"])
                data = resp.read()
                self.log.debug("Probed chunk %s (len %d)" % (uri, len(data)))
                if len(self.loaded) > 96:
                    self.loaded = self.loaded[32:]
            except IOError:
                self.log.error("Error on read %s of %s %s" % (uri, group, stream))
                self.err("status", "chunk", group, stream, uri)
            except KeyboardInterrupt:
                self.log.info("Finalize media prober %s." % self.pno)

    def analyze(self):
        """ TODO Analyze with Mediainfo.
        """
        pass


class Source:
    """ Reads config data and puts urls to task queue.
    """
    def __init__(self, cf, playlistq, log):
        """ Initialized with `cf` config dictionary
        `playlistq` playlist queue, and `log` logger object.
        """
        self.cf = cf
        self.playlistq = playlistq
        self.streams = cf["streams"]
        self.log = log
        self.streamlist = []
        self._walk(cf["streams"])

    def _walk(self, streams, parent=""):
        """ Recursive walk of `streams` configuration tree.
        """
        if type(streams) == dict:
            for key in streams.keys():
                if parent:
                    parent += "/%s" % key
                else:
                    parent = key
                self._walk(streams[key], parent)
        elif type(streams) == list:
            for val in streams:
                if type(val) == str and val.startswith("http"):
                    self.streamlist.append((parent, val))
                elif type(val) is dict:
                    self._walk(val, parent)
        elif type(streams) == str:
            self.streamlist.append((parent, streams))

    def __call__(self):
        """ Read the channel list and put tasks to playlist queue.
        """
        while True:
            try:
                if self.playlistq.full():
                    self.log.debug("Playlist queue is full. Probably you need to increase number of stream probers. Check `workers/stream-probers` value.")
                    time.sleep(3)
                    continue
                choice = random.choice(self.streamlist)
                self.playlistq.put(choice)
                time.sleep(self.cf["sleep"]["streams-list"])
            except KeyboardInterrupt:
                self.log.info("Exit source parser.")

    def get_streams(self):
        return self.streamlist


class ErrContainer:
    """ Container for transferring error messages between processes.
    """
    errors = ['timeout',  # request timeout, resource not available
              'status',   # status not equal 200 (resource not found, forbidden, etc.)
              'empty',    # playlist or chunk is empty
              'meta',
              'other']     # incorrect media info on chunk data or stream metadata

    def __init__(self, bugq):
        """ Initialized with `bugq` bug queue and `where` place where error appear.
        """
        self.bugq = bugq
        self.category = "other"
        self.objtype = ""
        self.group = ""
        self.uri = ""
        self.desc = ""

    def __call__(self, category="other", objtype="", group="", uri="", desc=""):
        self.stamp = time.time()
        self.category = category
        self.objtype = objtype
        self.group = group
        self.uri = uri
        self.desc = desc
        self.put.bugq(self)

class ProblemAnalyzer:
    """ Gather and analyze problems with streams. Log it or send mail on critical incidents.
    Probers generate errors of types: timeout, status, empty, media. 
    """
    def __init__(self, cf, bugq, log):
        """ Initialized with `bugq` bug queue and `log` logger object.
        """
        self.bugq = bugq
        self.log = log
        self.notify = Notify(cf, log)

    def __call__(self):
        while True:
            try:
                err = self.bugq.get(True)
                print "Error:",
                pprint(err)
                self.notify.send("%s %s %s\n%s" % (err[0], err[1], err[2], err[3]))
            except KeyboardInterrupt:
                self.log.info("Exit problem analyzer.")


class Notify:
    """ Send emails if problems detected.
    """
    def __init__(self, cf, log):
        """ Initialized with mail configuration.
        """
        self.subject = cf["notify"]["subject"]
        self.author = cf["notify"]["author"]
        self.to = cf["notify"]["adresses"]
        self.log = log

    def send(self, text):
        msg = MIMEText(text)
        msg['Subject'] = os.path.expandvars(self.subject)
        msg['From'] = self.author
        msg['To'] = self.to
        mail = smtplib.SMTP("localhost")
        mail.sendmail(self.author, self.to.split(';'), msg.as_string())
        mail.quit()


class Config:
    """ YAML configuration.
    """
    def __init__(self, cf, log):
        """ Initialized with config dictionary and logger object.
        """
        self.cf = cf
        try:
            # TODO apply defaults
            self.cfg = yaml.load(open(os.path.expanduser(cf)).read())
            log.debug("Loaded configuration from the %s." % os.path.expanduser(cf))
        except IOError:
            log.fatal("Can't open config file. Exit.")
            exit(1)
        except yaml.scanner.ScannerError, e:
            log.fatal("Error parsing config: %s" % e)
            exit(1)

    def __call__(self):
        return self.cfg


class FlowController:
    """ Manage all probe-tasks over workers.
    """
    def __init__(self, cf, log):
        self.log = log
        self.slots = []
        cf = Config(cf, log)()
        playlistq = Queue(cf["workers"]["stream-probers"]*6)
        chunkq = Queue(cf["workers"]["media-probers"]*12)
        bugq = Queue(cf["workers"]["stream-probers"]*2 + cf["workers"]["media-probers"]*2)
        for i in range(1, cf["workers"]["stream-probers"]):
            self.slots.append(Process(target=CupertinoProbe(cf, playlistq, chunkq, bugq, i, log)))
        log.debug("%d stream probers forked." % cf["workers"]["stream-probers"])
        for i in range(1, cf["workers"]["stream-probers"]):
            self.slots.append(Process(target=MediaProbe(cf, chunkq, bugq, i, log)))
        log.debug("%d media probers forked." % cf["workers"]["media-probers"])
        self.slots.append(Process(target=Source(cf, playlistq, log)))
        self.slots.append(Process(target=ProblemAnalyzer(cf, bugq, log)))

    def run(self):
        for slot in self.slots:
            slot.start()
        try:
            signal.pause()
        except KeyboardInterrupt:
            for slot in self.slots:
                self.log.info("Exit subprocess %s" % slot.pid)
                time.sleep(0.01)
                slot.terminate()
            self.log.info("Control process %s was interrupted by operator." % os.getpid())


def init_log(level=logging.WARN):
    """ Customizable logging to STDERR.
    """
    log = logging.getLogger("hlsprobe")
    hdlr = logging.StreamHandler(sys.stderr)
    formatter = logging.Formatter("%(asctime)s %(levelname)s %(message)s")
    hdlr.setFormatter(formatter)
    log.addHandler(hdlr)
    log.setLevel(level)
    return log


def main():
    """ Workflow:
    Source -[playlist url]-> TaskQueue ->>> CupertinoProbe -[chunk url]-> TaskQueue -> MediaProbe [bool]
    """
    cli = optparse.OptionParser()
    cli.add_option("--show-config", action="store_true", dest="show_config", help="Show parsed config (for debug purposes).")
    cli.add_option("--config", dest="cf", help="Use alternative configuration file.")
    cli.add_option("-v", "--verbose", dest="verbose", action="store_true", help="Show more probing details (for debug purposes).")
    opt, arg = cli.parse_args()
    if opt.cf:
        cf = opt.cf
    else:
        cf = CONFIG
    if opt.show_config:
        pprint(Config(cf, init_log())())
        exit()
    if opt.verbose:
        level = logging.DEBUG
    else:
        level = logging.INFO
    log = init_log(level)
    log.info("HLS Probe v%s started" % __version__)
    flowc = FlowController(cf, log)
    flowc.run()


if __name__ == "__main__":
    main()

# TODO сообщать о проблемах конфигурации в очередь ошибок

