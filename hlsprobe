#!/usr/bin/env python2
# -*- coding:utf-8; mode:python -*-
# ॐ तारे तुत्तारे तुरे स्व
"""
HLS Prober for 451 Fahrenheit mediaserver.
Author: Alexander I.Grafov (Axel) <grafov@gmail.com>
This utility licensed under GPL v3.

Uses https://pypi.python.org/pypi/m3u8 for M3U8 playlists parsing.
Scripted in Python2 because m3u8 lib still don't work under Python3.
"""
__version__ = "0.1"

import sys
import os
import random
import time
import signal
import logging
import urllib2
import smtplib
import m3u8
import yaml
import optparse
from email.mime.text import MIMEText
from multiprocessing import Process, Queue
from subprocess import check_output, call, Popen, PIPE
from pprint import pprint

CONFIG = "~/.hlsproberc"


class CupertinoProbe:
    """ Parse variant and stream M3U8-playlists. Parser uses python `m3u8` library.
    Get playlist URLs from the task queue.
    """
    def __init__(self, playlistq, chunkq, bugq, pno, log):
        self.playlistq = playlistq
        self.chunkq = chunkq
        self.bugq = bugq
        self.pno = pno
        self.log = log

    def __call__(self):
        """ Read and parse a playlist."""
        while True:
            try:
                uri = self.playlistq.get(True)
                playlist = m3u8.load(uri)
                self.log.debug("Load playlist from %s" % uri)
                if playlist.is_variant:
                    # Load stream playlists and put them back to playlist queue
                    for stream in playlist.playlists:
                        while self.playlistq.full():
                            self.log.debug("Playlist queue is full.")
                            time.sleep(3)
                        self.playlistq.put("%s/%s" % (stream.baseuri, stream.uri))
                    else:
                        self.bugq.put({"list-empty": "%s/%s" % (stream.baseuri, stream.uri)})
                else:
                    # Load URLs to media chunks and put them to chunk queue
                    for seg in playlist.segments:
                        while self.chunkq.full():
                            self.log.debug("Chunk queue is full.")
                            time.sleep(3)
                        self.chunkq.put("%s/%s" % (playlist.baseuri, seg.uri))
            except KeyboardInterrupt:
                self.log.info("Finalize cupertino prober %s." % self.pno)
            except:
                self.log.warn("Failed to open %s stream" % uri)
                self.bugq.put({"no-stream": uri})
                continue


class MediaProbe:
    """ Get and analyze media chunks.
    """
    def __init__(self, chunkq, bugq, pno, log):
        self.chunkq = chunkq
        self.bugq = bugq
        self.pno = pno
        self.log = log
        self.loaded = [] # cache list of already loaded chunks

    def __call__(self):
        while True:
            try:
                uri = self.chunkq.get(True)
                if uri in self.loaded:
                    self.log.debug("Chunk %s already loaded." % uri)
                    continue
                resp = urllib2.urlopen(uri, timeout=6)
                data = resp.read()
                self.log.debug("Probed chunk %s (len %d)" % (uri, len(data)))
                if len(self.loaded) > 96:
                    self.loaded = self.loaded[32:]
            except IOError:
                self.log.error("Error on read %s" % uri)
            except KeyboardInterrupt:
                self.log.info("Finalize media prober %s." % self.pno)

    def analyze(self):
        """ TODO Analyze with Mediainfo.
        """
        pass


class Source:
    """ Reads config data and puts urls to task queue.
    """
    def __init__(self, playlistq, cf, log):
        """ На входе файл конфига `confile` и очередь задач `playlistq`.
        """
        self.playlistq = playlistq
        self.cf = cf
        self.streams = cf["streams"]
        self.log = log

    def __call__(self):
        """ Read the channel list and put tasks to playlist queue.
        """
        while True:
            try:
                if self.playlistq.full():
                    self.log.debug("Playlist queue is full.")
                    time.sleep(3)
                    continue
                self.playlistq.put(random.choice(self.streams))
                time.sleep(self.cf["timeouts"]["stream-list"])
            except KeyboardInterrupt:
                self.log.info("Exit source parser.")


class ProblemAnalyzer:
    """ Gather and analyze problems with streams. Log it or send mail on critical incidents.
    Probers generate errors of types: timeout, status, empty, media. 
    """
    errors = ['timeout',  # request timeout, resource not available
              'status',   # status not 200: resource not found, forbidden, etc.
              'empty',    # playlist or chunk is empty
              'media']    # incorrect media info on chunk data or stream metadata
    def __init__(self, bugq, log):
        """ Initialized with bug queue and logger.
        """
        self.bugq = bugq
        self.log = log

    def __call__(self):
        while True:
            try:
                err = self.bugq.get(True)
            except KeyboardInterrupt:
                self.log.info("Exit problem analyzer.")


class Notify:
    """ Send emails if problems detected.
    """
    def __init__(self, mailcf):
        """ Initialized with mail configuration.
        """
        self.subject = mailcf.subject
        self.author = mailcf.author
        self.to = mailcf.adresses

    def send(self, text):
        msg = MIMEText(text)
        msg['Subject'] = os.path.expandvars(self.subject)
        msg['From'] = self.author
        msg['To'] = self.to
        mail = smtplib.SMTP("localhost")
        mail.sendmail(self.author, [self.to.split(';')], msg.as_string())
        mail.quit()


class Config:
    """ YAML configuration.
    """
    def __init__(self, cf, log):
        self.cf = cf
        try:
            # TODO apply defaults
            self.cfg = yaml.load(open(os.path.expanduser(cf)).read())
            log.debug("Loaded configuration from the %s." % os.path.expanduser(cf))
        except IOError:
            log.fatal("Can't open config file. Exit.")
            exit(1)
        except yaml.scanner.ScannerError, e:
            log.fatal("Error parsing config: %s" % e)
            exit(1)

    def __call__(self):
        return self.cfg


class FlowController:
    """ Manage all probe-tasks over workers.
    """
    def __init__(self, cf, log):
        self.log = log
        playlistq = Queue(32)
        chunkq = Queue(96)
        bugq = Queue(16)
        self.slots = []
        cf = Config(cf, log)()
        for i in range(cf["workers"]["stream-probers"]):
            self.slots.append(Process(target=CupertinoProbe(playlistq, chunkq, bugq, i, self.log)))
        for i in range(cf["workers"]["stream-probers"]):
            self.slots.append(Process(target=MediaProbe(chunkq, bugq, i, self.log)))
        self.slots.append(Process(target=Source(playlistq, cf, self.log)))
        self.slots.append(Process(target=ProblemAnalyzer(bugq, self.log)))

    def run(self):
        for slot in self.slots:
            slot.start()
        try:
            signal.pause()
        except KeyboardInterrupt:
            for slot in self.slots:
                self.log.info("Exit subprocess %s" % slot.pid)
                slot.terminate()
            self.log.info("Control process %s interrupted by operator." % os.getpid())


def init_log(level=logging.WARN):
    """ Customizable logging to STDERR.
    """
    log = logging.getLogger("hlsprobe")
    hdlr = logging.StreamHandler(sys.stderr)
    formatter = logging.Formatter("%(asctime)s %(levelname)s %(message)s")
    hdlr.setFormatter(formatter)
    log.addHandler(hdlr)
    log.setLevel(level)
    return log


def main():
    """ Workflow:
    Source -[playlist url]-> TaskQueue ->>> CupertinoProbe -[chunk url]-> TaskQueue -> MediaProbe [bool]
    """
    cli = optparse.OptionParser()
    cli.add_option("--show-config", action="store_true", dest="show_config", help="Show parsed config (for debug purposes).")
    cli.add_option("--config", dest="cf", help="Use alternative configuration file.")
    cli.add_option("-v", "--verbose", dest="verbose", action="store_true", help="Show more probing details (for debug purposes).")
    opt, arg = cli.parse_args()
    if opt.cf:
        cf = opt.cf
    else:
        cf = CONFIG
    if opt.show_config:
        pprint(Config(cf, init_log())())
        exit()
    if opt.verbose:
        level = logging.DEBUG
    else:
        level = logging.INFO
    log = init_log(level)
    log.info("HLS Probe v%s started" % __version__)
    flowc = FlowController(cf, log)
    flowc.run()


if __name__ == "__main__":
    main()

